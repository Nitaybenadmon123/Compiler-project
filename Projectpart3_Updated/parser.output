

Terminals which are not used:

   BAR


Conflict in state 35 between rule 113 and token OR resolved as reduce.
Conflict in state 35 between rule 113 and token AND resolved as reduce.
Conflict in state 35 between rule 113 and token MULT resolved as reduce.
Conflict in state 35 between rule 113 and token NOT resolved as shift.
Conflict in state 77 between rule 118 and token OR resolved as reduce.
Conflict in state 77 between rule 118 and token AND resolved as reduce.
Conflict in state 77 between rule 118 and token PLUS resolved as reduce.
Conflict in state 77 between rule 118 and token MINUS resolved as reduce.
Conflict in state 77 between rule 118 and token MULT resolved as reduce.
Conflict in state 77 between rule 118 and token DIV resolved as reduce.
Conflict in state 77 between rule 118 and token EQ resolved as reduce.
Conflict in state 77 between rule 118 and token NE resolved as reduce.
Conflict in state 77 between rule 118 and token GT resolved as reduce.
Conflict in state 77 between rule 118 and token GE resolved as reduce.
Conflict in state 77 between rule 118 and token LT resolved as reduce.
Conflict in state 77 between rule 118 and token LE resolved as reduce.
Conflict in state 149 between rule 117 and token OR resolved as reduce.
Conflict in state 149 between rule 117 and token AND resolved as shift.
Conflict in state 149 between rule 117 and token PLUS resolved as shift.
Conflict in state 149 between rule 117 and token MINUS resolved as shift.
Conflict in state 149 between rule 117 and token MULT resolved as shift.
Conflict in state 149 between rule 117 and token DIV resolved as shift.
Conflict in state 149 between rule 117 and token EQ resolved as shift.
Conflict in state 149 between rule 117 and token NE resolved as shift.
Conflict in state 149 between rule 117 and token GT resolved as shift.
Conflict in state 149 between rule 117 and token GE resolved as shift.
Conflict in state 149 between rule 117 and token LT resolved as shift.
Conflict in state 149 between rule 117 and token LE resolved as shift.
Conflict in state 150 between rule 116 and token OR resolved as reduce.
Conflict in state 150 between rule 116 and token AND resolved as reduce.
Conflict in state 150 between rule 116 and token PLUS resolved as shift.
Conflict in state 150 between rule 116 and token MINUS resolved as shift.
Conflict in state 150 between rule 116 and token MULT resolved as shift.
Conflict in state 150 between rule 116 and token DIV resolved as shift.
Conflict in state 150 between rule 116 and token EQ resolved as shift.
Conflict in state 150 between rule 116 and token NE resolved as shift.
Conflict in state 150 between rule 116 and token GT resolved as shift.
Conflict in state 150 between rule 116 and token GE resolved as shift.
Conflict in state 150 between rule 116 and token LT resolved as shift.
Conflict in state 150 between rule 116 and token LE resolved as shift.
Conflict in state 151 between rule 91 and token OR resolved as reduce.
Conflict in state 151 between rule 91 and token AND resolved as reduce.
Conflict in state 151 between rule 91 and token PLUS resolved as reduce.
Conflict in state 151 between rule 91 and token MINUS resolved as reduce.
Conflict in state 151 between rule 91 and token MULT resolved as shift.
Conflict in state 151 between rule 91 and token DIV resolved as shift.
Conflict in state 151 between rule 91 and token EQ resolved as shift.
Conflict in state 151 between rule 91 and token NE resolved as shift.
Conflict in state 151 between rule 91 and token GT resolved as shift.
Conflict in state 151 between rule 91 and token GE resolved as shift.
Conflict in state 151 between rule 91 and token LT resolved as shift.
Conflict in state 151 between rule 91 and token LE resolved as shift.
Conflict in state 152 between rule 92 and token OR resolved as reduce.
Conflict in state 152 between rule 92 and token AND resolved as reduce.
Conflict in state 152 between rule 92 and token PLUS resolved as reduce.
Conflict in state 152 between rule 92 and token MINUS resolved as reduce.
Conflict in state 152 between rule 92 and token MULT resolved as shift.
Conflict in state 152 between rule 92 and token DIV resolved as shift.
Conflict in state 152 between rule 92 and token EQ resolved as shift.
Conflict in state 152 between rule 92 and token NE resolved as shift.
Conflict in state 152 between rule 92 and token GT resolved as shift.
Conflict in state 152 between rule 92 and token GE resolved as shift.
Conflict in state 152 between rule 92 and token LT resolved as shift.
Conflict in state 152 between rule 92 and token LE resolved as shift.
Conflict in state 153 between rule 93 and token OR resolved as reduce.
Conflict in state 153 between rule 93 and token AND resolved as reduce.
Conflict in state 153 between rule 93 and token PLUS resolved as reduce.
Conflict in state 153 between rule 93 and token MINUS resolved as reduce.
Conflict in state 153 between rule 93 and token MULT resolved as reduce.
Conflict in state 153 between rule 93 and token DIV resolved as reduce.
Conflict in state 153 between rule 93 and token EQ resolved as shift.
Conflict in state 153 between rule 93 and token NE resolved as shift.
Conflict in state 153 between rule 93 and token GT resolved as shift.
Conflict in state 153 between rule 93 and token GE resolved as shift.
Conflict in state 153 between rule 93 and token LT resolved as shift.
Conflict in state 153 between rule 93 and token LE resolved as shift.
Conflict in state 154 between rule 94 and token OR resolved as reduce.
Conflict in state 154 between rule 94 and token AND resolved as reduce.
Conflict in state 154 between rule 94 and token PLUS resolved as reduce.
Conflict in state 154 between rule 94 and token MINUS resolved as reduce.
Conflict in state 154 between rule 94 and token MULT resolved as reduce.
Conflict in state 154 between rule 94 and token DIV resolved as reduce.
Conflict in state 154 between rule 94 and token EQ resolved as shift.
Conflict in state 154 between rule 94 and token NE resolved as shift.
Conflict in state 154 between rule 94 and token GT resolved as shift.
Conflict in state 154 between rule 94 and token GE resolved as shift.
Conflict in state 154 between rule 94 and token LT resolved as shift.
Conflict in state 154 between rule 94 and token LE resolved as shift.
Conflict in state 155 between rule 95 and token OR resolved as reduce.
Conflict in state 155 between rule 95 and token AND resolved as reduce.
Conflict in state 155 between rule 95 and token PLUS resolved as reduce.
Conflict in state 155 between rule 95 and token MINUS resolved as reduce.
Conflict in state 155 between rule 95 and token MULT resolved as reduce.
Conflict in state 155 between rule 95 and token DIV resolved as reduce.
Conflict in state 155 between rule 95 and token EQ resolved as reduce.
Conflict in state 155 between rule 95 and token NE resolved as reduce.
Conflict in state 155 between rule 95 and token GT resolved as reduce.
Conflict in state 155 between rule 95 and token GE resolved as reduce.
Conflict in state 155 between rule 95 and token LT resolved as reduce.
Conflict in state 155 between rule 95 and token LE resolved as reduce.
Conflict in state 156 between rule 96 and token OR resolved as reduce.
Conflict in state 156 between rule 96 and token AND resolved as reduce.
Conflict in state 156 between rule 96 and token PLUS resolved as reduce.
Conflict in state 156 between rule 96 and token MINUS resolved as reduce.
Conflict in state 156 between rule 96 and token MULT resolved as reduce.
Conflict in state 156 between rule 96 and token DIV resolved as reduce.
Conflict in state 156 between rule 96 and token EQ resolved as reduce.
Conflict in state 156 between rule 96 and token NE resolved as reduce.
Conflict in state 156 between rule 96 and token GT resolved as reduce.
Conflict in state 156 between rule 96 and token GE resolved as reduce.
Conflict in state 156 between rule 96 and token LT resolved as reduce.
Conflict in state 156 between rule 96 and token LE resolved as reduce.
Conflict in state 157 between rule 98 and token OR resolved as reduce.
Conflict in state 157 between rule 98 and token AND resolved as reduce.
Conflict in state 157 between rule 98 and token PLUS resolved as reduce.
Conflict in state 157 between rule 98 and token MINUS resolved as reduce.
Conflict in state 157 between rule 98 and token MULT resolved as reduce.
Conflict in state 157 between rule 98 and token DIV resolved as reduce.
Conflict in state 157 between rule 98 and token EQ resolved as reduce.
Conflict in state 157 between rule 98 and token NE resolved as reduce.
Conflict in state 157 between rule 98 and token GT resolved as reduce.
Conflict in state 157 between rule 98 and token GE resolved as reduce.
Conflict in state 157 between rule 98 and token LT resolved as reduce.
Conflict in state 157 between rule 98 and token LE resolved as reduce.
Conflict in state 158 between rule 100 and token OR resolved as reduce.
Conflict in state 158 between rule 100 and token AND resolved as reduce.
Conflict in state 158 between rule 100 and token PLUS resolved as reduce.
Conflict in state 158 between rule 100 and token MINUS resolved as reduce.
Conflict in state 158 between rule 100 and token MULT resolved as reduce.
Conflict in state 158 between rule 100 and token DIV resolved as reduce.
Conflict in state 158 between rule 100 and token EQ resolved as reduce.
Conflict in state 158 between rule 100 and token NE resolved as reduce.
Conflict in state 158 between rule 100 and token GT resolved as reduce.
Conflict in state 158 between rule 100 and token GE resolved as reduce.
Conflict in state 158 between rule 100 and token LT resolved as reduce.
Conflict in state 158 between rule 100 and token LE resolved as reduce.
Conflict in state 159 between rule 97 and token OR resolved as reduce.
Conflict in state 159 between rule 97 and token AND resolved as reduce.
Conflict in state 159 between rule 97 and token PLUS resolved as reduce.
Conflict in state 159 between rule 97 and token MINUS resolved as reduce.
Conflict in state 159 between rule 97 and token MULT resolved as reduce.
Conflict in state 159 between rule 97 and token DIV resolved as reduce.
Conflict in state 159 between rule 97 and token EQ resolved as reduce.
Conflict in state 159 between rule 97 and token NE resolved as reduce.
Conflict in state 159 between rule 97 and token GT resolved as reduce.
Conflict in state 159 between rule 97 and token GE resolved as reduce.
Conflict in state 159 between rule 97 and token LT resolved as reduce.
Conflict in state 159 between rule 97 and token LE resolved as reduce.
Conflict in state 160 between rule 99 and token OR resolved as reduce.
Conflict in state 160 between rule 99 and token AND resolved as reduce.
Conflict in state 160 between rule 99 and token PLUS resolved as reduce.
Conflict in state 160 between rule 99 and token MINUS resolved as reduce.
Conflict in state 160 between rule 99 and token MULT resolved as reduce.
Conflict in state 160 between rule 99 and token DIV resolved as reduce.
Conflict in state 160 between rule 99 and token EQ resolved as reduce.
Conflict in state 160 between rule 99 and token NE resolved as reduce.
Conflict in state 160 between rule 99 and token GT resolved as reduce.
Conflict in state 160 between rule 99 and token GE resolved as reduce.
Conflict in state 160 between rule 99 and token LT resolved as reduce.
Conflict in state 160 between rule 99 and token LE resolved as reduce.
State 7 contains 1 shift/reduce conflict.
State 27 contains 23 shift/reduce conflicts.
State 35 contains 11 shift/reduce conflicts.
State 36 contains 2 shift/reduce conflicts.
State 42 contains 1 reduce/reduce conflict.
State 54 contains 1 shift/reduce conflict.
State 55 contains 23 shift/reduce conflicts and 26 reduce/reduce conflicts.
State 69 contains 3 shift/reduce conflicts.
State 71 contains 23 shift/reduce conflicts.
State 72 contains 23 shift/reduce conflicts.
State 75 contains 2 shift/reduce conflicts.
State 81 contains 23 shift/reduce conflicts.
State 87 contains 23 shift/reduce conflicts.
State 92 contains 23 shift/reduce conflicts.
State 112 contains 23 shift/reduce conflicts and 26 reduce/reduce conflicts.
State 113 contains 23 shift/reduce conflicts and 26 reduce/reduce conflicts.
State 122 contains 24 shift/reduce conflicts.
State 124 contains 23 shift/reduce conflicts.
State 126 contains 23 shift/reduce conflicts.
State 130 contains 23 shift/reduce conflicts.
State 131 contains 1 shift/reduce conflict.
State 132 contains 1 shift/reduce conflict.
State 145 contains 26 reduce/reduce conflicts.
State 148 contains 3 shift/reduce conflicts.
State 161 contains 23 shift/reduce conflicts.
State 170 contains 1 shift/reduce conflict.
State 171 contains 1 shift/reduce conflict and 26 reduce/reduce conflicts.
State 174 contains 26 reduce/reduce conflicts.
State 191 contains 23 shift/reduce conflicts and 26 reduce/reduce conflicts.
State 218 contains 23 shift/reduce conflicts.
State 245 contains 1 shift/reduce conflict.
State 266 contains 23 shift/reduce conflicts.
State 276 contains 26 reduce/reduce conflicts.

Grammar
rule 1    program -> func_list
rule 2    program -> error
rule 3    func_list -> func_list function
rule 4    func_list -> function
rule 5    @1 ->		/* empty */
rule 6    function -> DEF ID LPAREN par_list RPAREN COLON RETURNS type @1 stmt_list
rule 7    @2 ->		/* empty */
rule 8    function -> DEF ID LPAREN RPAREN COLON RETURNS type @2 stmt_list
rule 9    @3 ->		/* empty */
rule 10   function -> DEF ID LPAREN par_list RPAREN COLON @3 stmt_list
rule 11   @4 ->		/* empty */
rule 12   function -> DEF ID LPAREN RPAREN COLON @4 stmt_list
rule 13   par_list -> param_list_item_list
rule 14   par_list ->		/* empty */
rule 15   param_list_item_list -> param_list_item_list SEMICOLON par_list_item
rule 16   param_list_item_list -> par_list_item
rule 17   par_list_item -> ID type COLON ID
rule 18   type -> TYPE_INT
rule 19   type -> TYPE_CHAR
rule 20   type -> TYPE_REAL
rule 21   type -> TYPE_BOOL
rule 22   type -> TYPE_STRING
rule 23   type -> TYPE_INT_PTR
rule 24   type -> TYPE_CHAR_PTR
rule 25   type -> TYPE_REAL_PTR
rule 26   stmt_list -> stmt_list stmt
rule 27   stmt_list -> stmt
rule 28   stmt -> assignment
rule 29   stmt -> if_stmt
rule 30   stmt -> return_stmt
rule 31   stmt -> block
rule 32   stmt -> while_stmt
rule 33   stmt -> for_stmt
rule 34   stmt -> call_args
rule 35   stmt -> do_while_stmt
rule 36   stmt -> var_stmt
rule 37   stmt -> void_call
rule 38   stmt -> assignment_call
rule 39   stmt -> func_list
rule 40   assignment -> ID ASSIGN expr SEMICOLON
rule 41   assignment -> ID LBRACK expr RBRACK ASSIGN expr SEMICOLON
rule 42   assignment -> MULT ID ASSIGN expr SEMICOLON
rule 43   var_stmt -> VAR type_decls block
rule 44   var_stmt -> VAR type_decls stmt
rule 45   type_decls -> type_decls type_decl
rule 46   type_decls -> type_decl
rule 47   type_decl -> TYPE TYPE_INT COLON ID SEMICOLON
rule 48   type_decl -> TYPE TYPE_BOOL COLON ID SEMICOLON
rule 49   type_decl -> TYPE TYPE_CHAR COLON ID SEMICOLON
rule 50   type_decl -> TYPE TYPE_STRING COLON ID SEMICOLON
rule 51   type_decl -> TYPE TYPE_REAL COLON ID SEMICOLON
rule 52   type_decl -> TYPE TYPE_REAL COLON ID COLON NUM SEMICOLON
rule 53   type_decl -> TYPE TYPE_INT COLON ID COLON NUM SEMICOLON
rule 54   type_decl -> TYPE TYPE_CHAR COLON ID COLON CHAR_LITERAL SEMICOLON
rule 55   type_decl -> TYPE TYPE_STRING COLON ID COLON STRING_LITERAL SEMICOLON
rule 56   type_decl -> TYPE TYPE_BOOL COLON ID COLON TRUE SEMICOLON
rule 57   type_decl -> TYPE TYPE_BOOL COLON ID COLON FALSE SEMICOLON
rule 58   type_decl -> TYPE TYPE_STRING COLON ID LBRACK NUM RBRACK SEMICOLON
rule 59   type_decl -> TYPE TYPE_INT_PTR COLON ID SEMICOLON
rule 60   type_decl -> TYPE TYPE_CHAR_PTR COLON ID SEMICOLON
rule 61   type_decl -> TYPE TYPE_REAL_PTR COLON ID SEMICOLON
rule 62   return_stmt -> RETURN expr SEMICOLON
rule 63   return_stmt -> RETURN SEMICOLON
rule 64   if_stmt -> IF expr COLON block ELSE COLON block
rule 65   if_stmt -> IF expr COLON block
rule 66   if_stmt -> IF expr COLON stmt
rule 67   if_stmt -> IF expr COLON stmt ELSE COLON stmt
rule 68   if_stmt -> IF expr COLON block elif_list ELSE COLON block
rule 69   elif_list -> ELIF expr COLON block
rule 70   elif_list -> elif_list ELIF expr COLON block
rule 71   while_stmt -> WHILE COLON expr SEMICOLON
rule 72   while_stmt -> WHILE expr COLON block
rule 73   while_stmt -> WHILE expr COLON stmt
rule 74   do_while_stmt -> DO COLON stmt_list WHILE expr SEMICOLON
rule 75   do_while_stmt -> DO COLON stmt WHILE expr SEMICOLON
rule 76   do_while_stmt -> DO COLON block WHILE expr SEMICOLON
rule 77   for_stmt -> FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON block
rule 78   for_stmt -> FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON stmt
rule 79   update_expr -> ID ASSIGN expr
rule 80   update_expr -> expr
rule 81   call_args -> call_list
rule 82   call_args ->		/* empty */
rule 83   call_list -> call_list COMMA expr
rule 84   call_list -> expr
rule 85   assignment_call -> ID ASSIGN CALL ID LPAREN call_args RPAREN SEMICOLON
rule 86   void_call -> CALL ID LPAREN call_args RPAREN SEMICOLON
rule 87   @5 ->		/* empty */
rule 88   block -> T_BEGIN @5 stmt_list T_END
rule 89   @6 ->		/* empty */
rule 90   block -> T_BEGIN @6 T_END
rule 91   expr -> expr PLUS expr
rule 92   expr -> expr MINUS expr
rule 93   expr -> expr MULT expr
rule 94   expr -> expr DIV expr
rule 95   expr -> expr EQ expr
rule 96   expr -> expr NE expr
rule 97   expr -> expr LT expr
rule 98   expr -> expr GT expr
rule 99   expr -> expr LE expr
rule 100  expr -> expr GE expr
rule 101  expr -> LPAREN expr RPAREN
rule 102  expr -> ID LBRACK expr RBRACK
rule 103  expr -> LBRACK expr RBRACK
rule 104  expr -> NUM
rule 105  expr -> ID
rule 106  expr -> CHAR_LITERAL
rule 107  expr -> STRING_LITERAL
rule 108  expr -> NULLPTR
rule 109  expr -> TRUE
rule 110  expr -> FALSE
rule 111  expr -> AND
rule 112  expr -> OR
rule 113  expr -> NOT
rule 114  expr -> CALL ID LPAREN call_args RPAREN
rule 115  expr -> ID LPAREN call_args RPAREN
rule 116  expr -> expr AND expr
rule 117  expr -> expr OR expr
rule 118  expr -> NOT expr
rule 119  expr -> MULT ID
rule 120  expr -> ADDRESS ID

Terminals, with rules where they appear

$ (-1)
error (256) 2
OR (258) 112 117
AND (259) 111 116
PLUS (260) 91
MINUS (261) 92
MULT (262) 42 93 119
DIV (263) 94
EQ (264) 95
NE (265) 96
GT (266) 98
GE (267) 100
LT (268) 97
LE (269) 99
NOT (270) 113 118
ID (271) 6 8 10 12 17 40 41 42 47 48 49 50 51 52 53 54 55 56 57 58
    59 60 61 79 85 86 102 105 114 115 119 120
CHAR_LITERAL (272) 54 106
STRING_LITERAL (273) 55 107
NUM (274) 52 53 58 104
TRUE (275) 56 109
FALSE (276) 57 110
TYPE_INT (277) 18 47 53
TYPE_CHAR (278) 19 49 54
TYPE_REAL (279) 20 51 52
TYPE_BOOL (280) 21 48 56 57
TYPE_STRING (281) 22 50 55 58
TYPE_INT_PTR (282) 23 59
TYPE_CHAR_PTR (283) 24 60
TYPE_REAL_PTR (284) 25 61
DEF (285) 6 8 10 12
T_BEGIN (286) 88 90
T_END (287) 88 90
IF (288) 64 65 66 67 68
ELSE (289) 64 67 68
ELIF (290) 69 70
WHILE (291) 71 72 73 74 75 76
FOR (292) 77 78
DO (293) 74 75 76
CALL (294) 85 86 114
RETURN (295) 62 63
RETURNS (296) 6 8
VAR (297) 43 44
NULLPTR (298) 108
ASSIGN (299) 40 41 42 79 85
ADDRESS (300) 120
COLON (301) 6 8 10 12 17 47 48 49 50 51 52 53 54 55 56 57 58 59 60
    61 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78
SEMICOLON (302) 15 40 41 42 47 48 49 50 51 52 53 54 55 56 57 58 59
    60 61 62 63 71 74 75 76 77 78 85 86
COMMA (303) 83
LPAREN (304) 6 8 10 12 77 78 85 86 101 114 115
RPAREN (305) 6 8 10 12 77 78 85 86 101 114 115
LBRACK (306) 41 58 102 103
RBRACK (307) 41 58 102 103
BAR (308)
TYPE (309) 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61

Nonterminals, with rules where they appear

program (55)
    on left: 1 2
func_list (56)
    on left: 3 4, on right: 1 3 39
function (57)
    on left: 6 8 10 12, on right: 3 4
@1 (58)
    on left: 5, on right: 6
@2 (59)
    on left: 7, on right: 8
@3 (60)
    on left: 9, on right: 10
@4 (61)
    on left: 11, on right: 12
par_list (62)
    on left: 13 14, on right: 6 10
param_list_item_list (63)
    on left: 15 16, on right: 13 15
par_list_item (64)
    on left: 17, on right: 15 16
type (65)
    on left: 18 19 20 21 22 23 24 25, on right: 6 8 17
stmt_list (66)
    on left: 26 27, on right: 6 8 10 12 26 74 88
stmt (67)
    on left: 28 29 30 31 32 33 34 35 36 37 38 39, on right: 26 27 44
    66 67 73 75 78
assignment (68)
    on left: 40 41 42, on right: 28 77 78
var_stmt (69)
    on left: 43 44, on right: 36
type_decls (70)
    on left: 45 46, on right: 43 44 45
type_decl (71)
    on left: 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61,
    on right: 45 46
return_stmt (72)
    on left: 62 63, on right: 30
if_stmt (73)
    on left: 64 65 66 67 68, on right: 29
elif_list (74)
    on left: 69 70, on right: 68 70
while_stmt (75)
    on left: 71 72 73, on right: 32
do_while_stmt (76)
    on left: 74 75 76, on right: 35
for_stmt (77)
    on left: 77 78, on right: 33
update_expr (78)
    on left: 79 80, on right: 77 78
call_args (79)
    on left: 81 82, on right: 34 85 86 114 115
call_list (80)
    on left: 83 84, on right: 81 83
assignment_call (81)
    on left: 85, on right: 38
void_call (82)
    on left: 86, on right: 37
block (83)
    on left: 88 90, on right: 31 43 64 65 68 69 70 72 76 77
@5 (84)
    on left: 87, on right: 88
@6 (85)
    on left: 89, on right: 90
expr (86)
    on left: 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106
    107 108 109 110 111 112 113 114 115 116 117 118 119 120,
    on right: 40 41 42 62 64 65 66 67 68 69 70 71 72 73 74 75 76 77
    78 79 80 83 84 91 92 93 94 95 96 97 98 99 100 101 102 103 116 117
    118


state 0

    error	shift, and go to state 1
    DEF 	shift, and go to state 2

    program	go to state 278
    func_list	go to state 3
    function	go to state 4



state 1

    program  ->  error .   (rule 2)

    $default	reduce using rule 2 (program)



state 2

    function  ->  DEF . ID LPAREN par_list RPAREN COLON RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF . ID LPAREN RPAREN COLON RETURNS type @2 stmt_list   (rule 8)
    function  ->  DEF . ID LPAREN par_list RPAREN COLON @3 stmt_list   (rule 10)
    function  ->  DEF . ID LPAREN RPAREN COLON @4 stmt_list   (rule 12)

    ID  	shift, and go to state 5



state 3

    program  ->  func_list .   (rule 1)
    func_list  ->  func_list . function   (rule 3)

    DEF 	shift, and go to state 2

    $default	reduce using rule 1 (program)

    function	go to state 6



state 4

    func_list  ->  function .   (rule 4)

    $default	reduce using rule 4 (func_list)



state 5

    function  ->  DEF ID . LPAREN par_list RPAREN COLON RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF ID . LPAREN RPAREN COLON RETURNS type @2 stmt_list   (rule 8)
    function  ->  DEF ID . LPAREN par_list RPAREN COLON @3 stmt_list   (rule 10)
    function  ->  DEF ID . LPAREN RPAREN COLON @4 stmt_list   (rule 12)

    LPAREN	shift, and go to state 7



state 6

    func_list  ->  func_list function .   (rule 3)

    $default	reduce using rule 3 (func_list)



state 7

    function  ->  DEF ID LPAREN . par_list RPAREN COLON RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF ID LPAREN . RPAREN COLON RETURNS type @2 stmt_list   (rule 8)
    function  ->  DEF ID LPAREN . par_list RPAREN COLON @3 stmt_list   (rule 10)
    function  ->  DEF ID LPAREN . RPAREN COLON @4 stmt_list   (rule 12)

    ID  	shift, and go to state 8
    RPAREN	shift, and go to state 9

    RPAREN	[reduce using rule 14 (par_list)]
    $default	reduce using rule 14 (par_list)

    par_list	go to state 10
    param_list_item_list	go to state 11
    par_list_item	go to state 12



state 8

    par_list_item  ->  ID . type COLON ID   (rule 17)

    TYPE_INT	shift, and go to state 13
    TYPE_CHAR	shift, and go to state 14
    TYPE_REAL	shift, and go to state 15
    TYPE_BOOL	shift, and go to state 16
    TYPE_STRING	shift, and go to state 17
    TYPE_INT_PTR	shift, and go to state 18
    TYPE_CHAR_PTR	shift, and go to state 19
    TYPE_REAL_PTR	shift, and go to state 20

    type	go to state 21



state 9

    function  ->  DEF ID LPAREN RPAREN . COLON RETURNS type @2 stmt_list   (rule 8)
    function  ->  DEF ID LPAREN RPAREN . COLON @4 stmt_list   (rule 12)

    COLON	shift, and go to state 22



state 10

    function  ->  DEF ID LPAREN par_list . RPAREN COLON RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF ID LPAREN par_list . RPAREN COLON @3 stmt_list   (rule 10)

    RPAREN	shift, and go to state 23



state 11

    par_list  ->  param_list_item_list .   (rule 13)
    param_list_item_list  ->  param_list_item_list . SEMICOLON par_list_item   (rule 15)

    SEMICOLON	shift, and go to state 24

    $default	reduce using rule 13 (par_list)



state 12

    param_list_item_list  ->  par_list_item .   (rule 16)

    $default	reduce using rule 16 (param_list_item_list)



state 13

    type  ->  TYPE_INT .   (rule 18)

    $default	reduce using rule 18 (type)



state 14

    type  ->  TYPE_CHAR .   (rule 19)

    $default	reduce using rule 19 (type)



state 15

    type  ->  TYPE_REAL .   (rule 20)

    $default	reduce using rule 20 (type)



state 16

    type  ->  TYPE_BOOL .   (rule 21)

    $default	reduce using rule 21 (type)



state 17

    type  ->  TYPE_STRING .   (rule 22)

    $default	reduce using rule 22 (type)



state 18

    type  ->  TYPE_INT_PTR .   (rule 23)

    $default	reduce using rule 23 (type)



state 19

    type  ->  TYPE_CHAR_PTR .   (rule 24)

    $default	reduce using rule 24 (type)



state 20

    type  ->  TYPE_REAL_PTR .   (rule 25)

    $default	reduce using rule 25 (type)



state 21

    par_list_item  ->  ID type . COLON ID   (rule 17)

    COLON	shift, and go to state 25



state 22

    function  ->  DEF ID LPAREN RPAREN COLON . RETURNS type @2 stmt_list   (rule 8)
    function  ->  DEF ID LPAREN RPAREN COLON . @4 stmt_list   (rule 12)

    RETURNS	shift, and go to state 26

    $default	reduce using rule 11 (@4)

    @4  	go to state 27



state 23

    function  ->  DEF ID LPAREN par_list RPAREN . COLON RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF ID LPAREN par_list RPAREN . COLON @3 stmt_list   (rule 10)

    COLON	shift, and go to state 28



state 24

    param_list_item_list  ->  param_list_item_list SEMICOLON . par_list_item   (rule 15)

    ID  	shift, and go to state 8

    par_list_item	go to state 29



state 25

    par_list_item  ->  ID type COLON . ID   (rule 17)

    ID  	shift, and go to state 30



state 26

    function  ->  DEF ID LPAREN RPAREN COLON RETURNS . type @2 stmt_list   (rule 8)

    TYPE_INT	shift, and go to state 13
    TYPE_CHAR	shift, and go to state 14
    TYPE_REAL	shift, and go to state 15
    TYPE_BOOL	shift, and go to state 16
    TYPE_STRING	shift, and go to state 17
    TYPE_INT_PTR	shift, and go to state 18
    TYPE_CHAR_PTR	shift, and go to state 19
    TYPE_REAL_PTR	shift, and go to state 20

    type	go to state 31



state 27

    function  ->  DEF ID LPAREN RPAREN COLON @4 . stmt_list   (rule 12)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 55
    stmt	go to state 56
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 28

    function  ->  DEF ID LPAREN par_list RPAREN COLON . RETURNS type @1 stmt_list   (rule 6)
    function  ->  DEF ID LPAREN par_list RPAREN COLON . @3 stmt_list   (rule 10)

    RETURNS	shift, and go to state 70

    $default	reduce using rule 9 (@3)

    @3  	go to state 71



state 29

    param_list_item_list  ->  param_list_item_list SEMICOLON par_list_item .   (rule 15)

    $default	reduce using rule 15 (param_list_item_list)



state 30

    par_list_item  ->  ID type COLON ID .   (rule 17)

    $default	reduce using rule 17 (par_list_item)



state 31

    function  ->  DEF ID LPAREN RPAREN COLON RETURNS type . @2 stmt_list   (rule 8)

    $default	reduce using rule 7 (@2)

    @2  	go to state 72



state 32

    expr  ->  OR .   (rule 112)

    $default	reduce using rule 112 (expr)



state 33

    expr  ->  AND .   (rule 111)

    $default	reduce using rule 111 (expr)



state 34

    assignment  ->  MULT . ID ASSIGN expr SEMICOLON   (rule 42)
    expr  ->  MULT . ID   (rule 119)

    ID  	shift, and go to state 73



state 35

    expr  ->  NOT .   (rule 113)
    expr  ->  NOT . expr   (rule 118)

    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    ID  	[reduce using rule 113 (expr)]
    CHAR_LITERAL	[reduce using rule 113 (expr)]
    STRING_LITERAL	[reduce using rule 113 (expr)]
    NUM 	[reduce using rule 113 (expr)]
    TRUE	[reduce using rule 113 (expr)]
    FALSE	[reduce using rule 113 (expr)]
    CALL	[reduce using rule 113 (expr)]
    NULLPTR	[reduce using rule 113 (expr)]
    ADDRESS	[reduce using rule 113 (expr)]
    LPAREN	[reduce using rule 113 (expr)]
    LBRACK	[reduce using rule 113 (expr)]
    $default	reduce using rule 113 (expr)

    expr	go to state 77



state 36

    assignment  ->  ID . ASSIGN expr SEMICOLON   (rule 40)
    assignment  ->  ID . LBRACK expr RBRACK ASSIGN expr SEMICOLON   (rule 41)
    assignment_call  ->  ID . ASSIGN CALL ID LPAREN call_args RPAREN SEMICOLON   (rule 85)
    expr  ->  ID . LBRACK expr RBRACK   (rule 102)
    expr  ->  ID .   (rule 105)
    expr  ->  ID . LPAREN call_args RPAREN   (rule 115)

    ASSIGN	shift, and go to state 78
    LPAREN	shift, and go to state 79
    LBRACK	shift, and go to state 80

    LPAREN	[reduce using rule 105 (expr)]
    LBRACK	[reduce using rule 105 (expr)]
    $default	reduce using rule 105 (expr)



state 37

    expr  ->  CHAR_LITERAL .   (rule 106)

    $default	reduce using rule 106 (expr)



state 38

    expr  ->  STRING_LITERAL .   (rule 107)

    $default	reduce using rule 107 (expr)



state 39

    expr  ->  NUM .   (rule 104)

    $default	reduce using rule 104 (expr)



state 40

    expr  ->  TRUE .   (rule 109)

    $default	reduce using rule 109 (expr)



state 41

    expr  ->  FALSE .   (rule 110)

    $default	reduce using rule 110 (expr)



state 42

    block  ->  T_BEGIN . @5 stmt_list T_END   (rule 88)
    block  ->  T_BEGIN . @6 T_END   (rule 90)

    $default	reduce using rule 87 (@5)

    @5  	go to state 81
    @6  	go to state 82



state 43

    if_stmt  ->  IF . expr COLON block ELSE COLON block   (rule 64)
    if_stmt  ->  IF . expr COLON block   (rule 65)
    if_stmt  ->  IF . expr COLON stmt   (rule 66)
    if_stmt  ->  IF . expr COLON stmt ELSE COLON stmt   (rule 67)
    if_stmt  ->  IF . expr COLON block elif_list ELSE COLON block   (rule 68)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 83



state 44

    while_stmt  ->  WHILE . COLON expr SEMICOLON   (rule 71)
    while_stmt  ->  WHILE . expr COLON block   (rule 72)
    while_stmt  ->  WHILE . expr COLON stmt   (rule 73)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    COLON	shift, and go to state 84
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 85



state 45

    for_stmt  ->  FOR . LPAREN assignment expr SEMICOLON update_expr RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR . LPAREN assignment expr SEMICOLON update_expr RPAREN COLON stmt   (rule 78)

    LPAREN	shift, and go to state 86



state 46

    do_while_stmt  ->  DO . COLON stmt_list WHILE expr SEMICOLON   (rule 74)
    do_while_stmt  ->  DO . COLON stmt WHILE expr SEMICOLON   (rule 75)
    do_while_stmt  ->  DO . COLON block WHILE expr SEMICOLON   (rule 76)

    COLON	shift, and go to state 87



state 47

    void_call  ->  CALL . ID LPAREN call_args RPAREN SEMICOLON   (rule 86)
    expr  ->  CALL . ID LPAREN call_args RPAREN   (rule 114)

    ID  	shift, and go to state 88



state 48

    return_stmt  ->  RETURN . expr SEMICOLON   (rule 62)
    return_stmt  ->  RETURN . SEMICOLON   (rule 63)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    SEMICOLON	shift, and go to state 89
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 90



state 49

    var_stmt  ->  VAR . type_decls block   (rule 43)
    var_stmt  ->  VAR . type_decls stmt   (rule 44)

    TYPE	shift, and go to state 91

    type_decls	go to state 92
    type_decl	go to state 93



state 50

    expr  ->  NULLPTR .   (rule 108)

    $default	reduce using rule 108 (expr)



state 51

    expr  ->  ADDRESS . ID   (rule 120)

    ID  	shift, and go to state 94



state 52

    expr  ->  LPAREN . expr RPAREN   (rule 101)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 95



state 53

    expr  ->  LBRACK . expr RBRACK   (rule 103)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 96



state 54

    func_list  ->  func_list . function   (rule 3)
    stmt  ->  func_list .   (rule 39)

    DEF 	shift, and go to state 2

    DEF 	[reduce using rule 39 (stmt)]
    $default	reduce using rule 39 (stmt)

    function	go to state 6



state 55

    function  ->  DEF ID LPAREN RPAREN COLON @4 stmt_list .   (rule 12)
    stmt_list  ->  stmt_list . stmt   (rule 26)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $   	reduce using rule 12 (function)
    $   	[reduce using rule 82 (call_args)]
    OR  	[reduce using rule 12 (function)]
    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 12 (function)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 12 (function)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 12 (function)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 12 (function)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 12 (function)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 12 (function)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 12 (function)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 12 (function)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 12 (function)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 12 (function)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 12 (function)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    T_END	reduce using rule 12 (function)
    T_END	[reduce using rule 82 (call_args)]
    ELIF	reduce using rule 12 (function)
    ELIF	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 12 (function)]
    WHILE	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 12 (function)]
    CALL	[reduce using rule 82 (call_args)]
    SEMICOLON	reduce using rule 12 (function)
    SEMICOLON	[reduce using rule 82 (call_args)]
    COMMA	reduce using rule 12 (function)
    COMMA	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 12 (function)]
    LPAREN	[reduce using rule 82 (call_args)]
    RPAREN	reduce using rule 12 (function)
    RPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 12 (function)]
    LBRACK	[reduce using rule 82 (call_args)]
    RBRACK	reduce using rule 12 (function)
    RBRACK	[reduce using rule 82 (call_args)]
    BAR 	reduce using rule 12 (function)
    BAR 	[reduce using rule 82 (call_args)]
    $default	reduce using rule 12 (function)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 56

    stmt_list  ->  stmt .   (rule 27)

    $default	reduce using rule 27 (stmt_list)



state 57

    stmt  ->  assignment .   (rule 28)

    $default	reduce using rule 28 (stmt)



state 58

    stmt  ->  var_stmt .   (rule 36)

    $default	reduce using rule 36 (stmt)



state 59

    stmt  ->  return_stmt .   (rule 30)

    $default	reduce using rule 30 (stmt)



state 60

    stmt  ->  if_stmt .   (rule 29)

    $default	reduce using rule 29 (stmt)



state 61

    stmt  ->  while_stmt .   (rule 32)

    $default	reduce using rule 32 (stmt)



state 62

    stmt  ->  do_while_stmt .   (rule 35)

    $default	reduce using rule 35 (stmt)



state 63

    stmt  ->  for_stmt .   (rule 33)

    $default	reduce using rule 33 (stmt)



state 64

    stmt  ->  call_args .   (rule 34)

    $default	reduce using rule 34 (stmt)



state 65

    call_args  ->  call_list .   (rule 81)
    call_list  ->  call_list . COMMA expr   (rule 83)

    COMMA	shift, and go to state 98

    $default	reduce using rule 81 (call_args)



state 66

    stmt  ->  assignment_call .   (rule 38)

    $default	reduce using rule 38 (stmt)



state 67

    stmt  ->  void_call .   (rule 37)

    $default	reduce using rule 37 (stmt)



state 68

    stmt  ->  block .   (rule 31)

    $default	reduce using rule 31 (stmt)



state 69

    call_list  ->  expr .   (rule 84)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    OR  	[reduce using rule 84 (call_list)]
    AND 	[reduce using rule 84 (call_list)]
    MULT	[reduce using rule 84 (call_list)]
    $default	reduce using rule 84 (call_list)



state 70

    function  ->  DEF ID LPAREN par_list RPAREN COLON RETURNS . type @1 stmt_list   (rule 6)

    TYPE_INT	shift, and go to state 13
    TYPE_CHAR	shift, and go to state 14
    TYPE_REAL	shift, and go to state 15
    TYPE_BOOL	shift, and go to state 16
    TYPE_STRING	shift, and go to state 17
    TYPE_INT_PTR	shift, and go to state 18
    TYPE_CHAR_PTR	shift, and go to state 19
    TYPE_REAL_PTR	shift, and go to state 20

    type	go to state 111



state 71

    function  ->  DEF ID LPAREN par_list RPAREN COLON @3 . stmt_list   (rule 10)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 112
    stmt	go to state 56
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 72

    function  ->  DEF ID LPAREN RPAREN COLON RETURNS type @2 . stmt_list   (rule 8)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 113
    stmt	go to state 56
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 73

    assignment  ->  MULT ID . ASSIGN expr SEMICOLON   (rule 42)
    expr  ->  MULT ID .   (rule 119)

    ASSIGN	shift, and go to state 114

    $default	reduce using rule 119 (expr)



state 74

    expr  ->  MULT . ID   (rule 119)

    ID  	shift, and go to state 115



state 75

    expr  ->  ID . LBRACK expr RBRACK   (rule 102)
    expr  ->  ID .   (rule 105)
    expr  ->  ID . LPAREN call_args RPAREN   (rule 115)

    LPAREN	shift, and go to state 79
    LBRACK	shift, and go to state 116

    LPAREN	[reduce using rule 105 (expr)]
    LBRACK	[reduce using rule 105 (expr)]
    $default	reduce using rule 105 (expr)



state 76

    expr  ->  CALL . ID LPAREN call_args RPAREN   (rule 114)

    ID  	shift, and go to state 117



state 77

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)
    expr  ->  NOT expr .   (rule 118)


    $default	reduce using rule 118 (expr)



state 78

    assignment  ->  ID ASSIGN . expr SEMICOLON   (rule 40)
    assignment_call  ->  ID ASSIGN . CALL ID LPAREN call_args RPAREN SEMICOLON   (rule 85)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 118
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 119



state 79

    expr  ->  ID LPAREN . call_args RPAREN   (rule 115)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $default	reduce using rule 82 (call_args)

    call_args	go to state 120
    call_list	go to state 65
    expr	go to state 69



state 80

    assignment  ->  ID LBRACK . expr RBRACK ASSIGN expr SEMICOLON   (rule 41)
    expr  ->  ID LBRACK . expr RBRACK   (rule 102)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 121



state 81

    block  ->  T_BEGIN @5 . stmt_list T_END   (rule 88)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 122
    stmt	go to state 56
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 82

    block  ->  T_BEGIN @6 . T_END   (rule 90)

    T_END	shift, and go to state 123



state 83

    if_stmt  ->  IF expr . COLON block ELSE COLON block   (rule 64)
    if_stmt  ->  IF expr . COLON block   (rule 65)
    if_stmt  ->  IF expr . COLON stmt   (rule 66)
    if_stmt  ->  IF expr . COLON stmt ELSE COLON stmt   (rule 67)
    if_stmt  ->  IF expr . COLON block elif_list ELSE COLON block   (rule 68)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    COLON	shift, and go to state 124



state 84

    while_stmt  ->  WHILE COLON . expr SEMICOLON   (rule 71)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 125



state 85

    while_stmt  ->  WHILE expr . COLON block   (rule 72)
    while_stmt  ->  WHILE expr . COLON stmt   (rule 73)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    COLON	shift, and go to state 126



state 86

    for_stmt  ->  FOR LPAREN . assignment expr SEMICOLON update_expr RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN . assignment expr SEMICOLON update_expr RPAREN COLON stmt   (rule 78)

    MULT	shift, and go to state 127
    ID  	shift, and go to state 128

    assignment	go to state 129



state 87

    do_while_stmt  ->  DO COLON . stmt_list WHILE expr SEMICOLON   (rule 74)
    do_while_stmt  ->  DO COLON . stmt WHILE expr SEMICOLON   (rule 75)
    do_while_stmt  ->  DO COLON . block WHILE expr SEMICOLON   (rule 76)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 130
    stmt	go to state 131
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 132
    expr	go to state 69



state 88

    void_call  ->  CALL ID . LPAREN call_args RPAREN SEMICOLON   (rule 86)
    expr  ->  CALL ID . LPAREN call_args RPAREN   (rule 114)

    LPAREN	shift, and go to state 133



state 89

    return_stmt  ->  RETURN SEMICOLON .   (rule 63)

    $default	reduce using rule 63 (return_stmt)



state 90

    return_stmt  ->  RETURN expr . SEMICOLON   (rule 62)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 134



state 91

    type_decl  ->  TYPE . TYPE_INT COLON ID SEMICOLON   (rule 47)
    type_decl  ->  TYPE . TYPE_BOOL COLON ID SEMICOLON   (rule 48)
    type_decl  ->  TYPE . TYPE_CHAR COLON ID SEMICOLON   (rule 49)
    type_decl  ->  TYPE . TYPE_STRING COLON ID SEMICOLON   (rule 50)
    type_decl  ->  TYPE . TYPE_REAL COLON ID SEMICOLON   (rule 51)
    type_decl  ->  TYPE . TYPE_REAL COLON ID COLON NUM SEMICOLON   (rule 52)
    type_decl  ->  TYPE . TYPE_INT COLON ID COLON NUM SEMICOLON   (rule 53)
    type_decl  ->  TYPE . TYPE_CHAR COLON ID COLON CHAR_LITERAL SEMICOLON   (rule 54)
    type_decl  ->  TYPE . TYPE_STRING COLON ID COLON STRING_LITERAL SEMICOLON   (rule 55)
    type_decl  ->  TYPE . TYPE_BOOL COLON ID COLON TRUE SEMICOLON   (rule 56)
    type_decl  ->  TYPE . TYPE_BOOL COLON ID COLON FALSE SEMICOLON   (rule 57)
    type_decl  ->  TYPE . TYPE_STRING COLON ID LBRACK NUM RBRACK SEMICOLON   (rule 58)
    type_decl  ->  TYPE . TYPE_INT_PTR COLON ID SEMICOLON   (rule 59)
    type_decl  ->  TYPE . TYPE_CHAR_PTR COLON ID SEMICOLON   (rule 60)
    type_decl  ->  TYPE . TYPE_REAL_PTR COLON ID SEMICOLON   (rule 61)

    TYPE_INT	shift, and go to state 135
    TYPE_CHAR	shift, and go to state 136
    TYPE_REAL	shift, and go to state 137
    TYPE_BOOL	shift, and go to state 138
    TYPE_STRING	shift, and go to state 139
    TYPE_INT_PTR	shift, and go to state 140
    TYPE_CHAR_PTR	shift, and go to state 141
    TYPE_REAL_PTR	shift, and go to state 142



state 92

    var_stmt  ->  VAR type_decls . block   (rule 43)
    var_stmt  ->  VAR type_decls . stmt   (rule 44)
    type_decls  ->  type_decls . type_decl   (rule 45)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53
    TYPE	shift, and go to state 91

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 143
    assignment	go to state 57
    var_stmt	go to state 58
    type_decl	go to state 144
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 145
    expr	go to state 69



state 93

    type_decls  ->  type_decl .   (rule 46)

    $default	reduce using rule 46 (type_decls)



state 94

    expr  ->  ADDRESS ID .   (rule 120)

    $default	reduce using rule 120 (expr)



state 95

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  LPAREN expr . RPAREN   (rule 101)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    RPAREN	shift, and go to state 146



state 96

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  LBRACK expr . RBRACK   (rule 103)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    RBRACK	shift, and go to state 147



state 97

    stmt_list  ->  stmt_list stmt .   (rule 26)

    $default	reduce using rule 26 (stmt_list)



state 98

    call_list  ->  call_list COMMA . expr   (rule 83)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 148



state 99

    expr  ->  expr OR . expr   (rule 117)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 149



state 100

    expr  ->  expr AND . expr   (rule 116)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 150



state 101

    expr  ->  expr PLUS . expr   (rule 91)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 151



state 102

    expr  ->  expr MINUS . expr   (rule 92)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 152



state 103

    expr  ->  expr MULT . expr   (rule 93)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 153



state 104

    expr  ->  expr DIV . expr   (rule 94)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 154



state 105

    expr  ->  expr EQ . expr   (rule 95)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 155



state 106

    expr  ->  expr NE . expr   (rule 96)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 156



state 107

    expr  ->  expr GT . expr   (rule 98)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 157



state 108

    expr  ->  expr GE . expr   (rule 100)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 158



state 109

    expr  ->  expr LT . expr   (rule 97)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 159



state 110

    expr  ->  expr LE . expr   (rule 99)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 160



state 111

    function  ->  DEF ID LPAREN par_list RPAREN COLON RETURNS type . @1 stmt_list   (rule 6)

    $default	reduce using rule 5 (@1)

    @1  	go to state 161



state 112

    function  ->  DEF ID LPAREN par_list RPAREN COLON @3 stmt_list .   (rule 10)
    stmt_list  ->  stmt_list . stmt   (rule 26)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $   	reduce using rule 10 (function)
    $   	[reduce using rule 82 (call_args)]
    OR  	[reduce using rule 10 (function)]
    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 10 (function)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 10 (function)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 10 (function)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 10 (function)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 10 (function)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 10 (function)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 10 (function)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 10 (function)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 10 (function)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 10 (function)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 10 (function)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    T_END	reduce using rule 10 (function)
    T_END	[reduce using rule 82 (call_args)]
    ELIF	reduce using rule 10 (function)
    ELIF	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 10 (function)]
    WHILE	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 10 (function)]
    CALL	[reduce using rule 82 (call_args)]
    SEMICOLON	reduce using rule 10 (function)
    SEMICOLON	[reduce using rule 82 (call_args)]
    COMMA	reduce using rule 10 (function)
    COMMA	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 10 (function)]
    LPAREN	[reduce using rule 82 (call_args)]
    RPAREN	reduce using rule 10 (function)
    RPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 10 (function)]
    LBRACK	[reduce using rule 82 (call_args)]
    RBRACK	reduce using rule 10 (function)
    RBRACK	[reduce using rule 82 (call_args)]
    BAR 	reduce using rule 10 (function)
    BAR 	[reduce using rule 82 (call_args)]
    $default	reduce using rule 10 (function)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 113

    function  ->  DEF ID LPAREN RPAREN COLON RETURNS type @2 stmt_list .   (rule 8)
    stmt_list  ->  stmt_list . stmt   (rule 26)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $   	reduce using rule 8 (function)
    $   	[reduce using rule 82 (call_args)]
    OR  	[reduce using rule 8 (function)]
    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 8 (function)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 8 (function)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 8 (function)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 8 (function)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 8 (function)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 8 (function)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 8 (function)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 8 (function)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 8 (function)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 8 (function)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 8 (function)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    T_END	reduce using rule 8 (function)
    T_END	[reduce using rule 82 (call_args)]
    ELIF	reduce using rule 8 (function)
    ELIF	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 8 (function)]
    WHILE	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 8 (function)]
    CALL	[reduce using rule 82 (call_args)]
    SEMICOLON	reduce using rule 8 (function)
    SEMICOLON	[reduce using rule 82 (call_args)]
    COMMA	reduce using rule 8 (function)
    COMMA	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 8 (function)]
    LPAREN	[reduce using rule 82 (call_args)]
    RPAREN	reduce using rule 8 (function)
    RPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 8 (function)]
    LBRACK	[reduce using rule 82 (call_args)]
    RBRACK	reduce using rule 8 (function)
    RBRACK	[reduce using rule 82 (call_args)]
    BAR 	reduce using rule 8 (function)
    BAR 	[reduce using rule 82 (call_args)]
    $default	reduce using rule 8 (function)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 114

    assignment  ->  MULT ID ASSIGN . expr SEMICOLON   (rule 42)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 162



state 115

    expr  ->  MULT ID .   (rule 119)

    $default	reduce using rule 119 (expr)



state 116

    expr  ->  ID LBRACK . expr RBRACK   (rule 102)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 163



state 117

    expr  ->  CALL ID . LPAREN call_args RPAREN   (rule 114)

    LPAREN	shift, and go to state 164



state 118

    assignment_call  ->  ID ASSIGN CALL . ID LPAREN call_args RPAREN SEMICOLON   (rule 85)
    expr  ->  CALL . ID LPAREN call_args RPAREN   (rule 114)

    ID  	shift, and go to state 165



state 119

    assignment  ->  ID ASSIGN expr . SEMICOLON   (rule 40)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 166



state 120

    expr  ->  ID LPAREN call_args . RPAREN   (rule 115)

    RPAREN	shift, and go to state 167



state 121

    assignment  ->  ID LBRACK expr . RBRACK ASSIGN expr SEMICOLON   (rule 41)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  ID LBRACK expr . RBRACK   (rule 102)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    RBRACK	shift, and go to state 168



state 122

    stmt_list  ->  stmt_list . stmt   (rule 26)
    block  ->  T_BEGIN @5 stmt_list . T_END   (rule 88)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    T_END	shift, and go to state 169
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    T_END	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 123

    block  ->  T_BEGIN @6 T_END .   (rule 90)

    $default	reduce using rule 90 (block)



state 124

    if_stmt  ->  IF expr COLON . block ELSE COLON block   (rule 64)
    if_stmt  ->  IF expr COLON . block   (rule 65)
    if_stmt  ->  IF expr COLON . stmt   (rule 66)
    if_stmt  ->  IF expr COLON . stmt ELSE COLON stmt   (rule 67)
    if_stmt  ->  IF expr COLON . block elif_list ELSE COLON block   (rule 68)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 170
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 171
    expr	go to state 69



state 125

    while_stmt  ->  WHILE COLON expr . SEMICOLON   (rule 71)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 172



state 126

    while_stmt  ->  WHILE expr COLON . block   (rule 72)
    while_stmt  ->  WHILE expr COLON . stmt   (rule 73)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 173
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 174
    expr	go to state 69



state 127

    assignment  ->  MULT . ID ASSIGN expr SEMICOLON   (rule 42)

    ID  	shift, and go to state 175



state 128

    assignment  ->  ID . ASSIGN expr SEMICOLON   (rule 40)
    assignment  ->  ID . LBRACK expr RBRACK ASSIGN expr SEMICOLON   (rule 41)

    ASSIGN	shift, and go to state 176
    LBRACK	shift, and go to state 177



state 129

    for_stmt  ->  FOR LPAREN assignment . expr SEMICOLON update_expr RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment . expr SEMICOLON update_expr RPAREN COLON stmt   (rule 78)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 178



state 130

    stmt_list  ->  stmt_list . stmt   (rule 26)
    do_while_stmt  ->  DO COLON stmt_list . WHILE expr SEMICOLON   (rule 74)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 179
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 131

    stmt_list  ->  stmt .   (rule 27)
    do_while_stmt  ->  DO COLON stmt . WHILE expr SEMICOLON   (rule 75)

    WHILE	shift, and go to state 180

    WHILE	[reduce using rule 27 (stmt_list)]
    $default	reduce using rule 27 (stmt_list)



state 132

    stmt  ->  block .   (rule 31)
    do_while_stmt  ->  DO COLON block . WHILE expr SEMICOLON   (rule 76)

    WHILE	shift, and go to state 181

    WHILE	[reduce using rule 31 (stmt)]
    $default	reduce using rule 31 (stmt)



state 133

    void_call  ->  CALL ID LPAREN . call_args RPAREN SEMICOLON   (rule 86)
    expr  ->  CALL ID LPAREN . call_args RPAREN   (rule 114)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $default	reduce using rule 82 (call_args)

    call_args	go to state 182
    call_list	go to state 65
    expr	go to state 69



state 134

    return_stmt  ->  RETURN expr SEMICOLON .   (rule 62)

    $default	reduce using rule 62 (return_stmt)



state 135

    type_decl  ->  TYPE TYPE_INT . COLON ID SEMICOLON   (rule 47)
    type_decl  ->  TYPE TYPE_INT . COLON ID COLON NUM SEMICOLON   (rule 53)

    COLON	shift, and go to state 183



state 136

    type_decl  ->  TYPE TYPE_CHAR . COLON ID SEMICOLON   (rule 49)
    type_decl  ->  TYPE TYPE_CHAR . COLON ID COLON CHAR_LITERAL SEMICOLON   (rule 54)

    COLON	shift, and go to state 184



state 137

    type_decl  ->  TYPE TYPE_REAL . COLON ID SEMICOLON   (rule 51)
    type_decl  ->  TYPE TYPE_REAL . COLON ID COLON NUM SEMICOLON   (rule 52)

    COLON	shift, and go to state 185



state 138

    type_decl  ->  TYPE TYPE_BOOL . COLON ID SEMICOLON   (rule 48)
    type_decl  ->  TYPE TYPE_BOOL . COLON ID COLON TRUE SEMICOLON   (rule 56)
    type_decl  ->  TYPE TYPE_BOOL . COLON ID COLON FALSE SEMICOLON   (rule 57)

    COLON	shift, and go to state 186



state 139

    type_decl  ->  TYPE TYPE_STRING . COLON ID SEMICOLON   (rule 50)
    type_decl  ->  TYPE TYPE_STRING . COLON ID COLON STRING_LITERAL SEMICOLON   (rule 55)
    type_decl  ->  TYPE TYPE_STRING . COLON ID LBRACK NUM RBRACK SEMICOLON   (rule 58)

    COLON	shift, and go to state 187



state 140

    type_decl  ->  TYPE TYPE_INT_PTR . COLON ID SEMICOLON   (rule 59)

    COLON	shift, and go to state 188



state 141

    type_decl  ->  TYPE TYPE_CHAR_PTR . COLON ID SEMICOLON   (rule 60)

    COLON	shift, and go to state 189



state 142

    type_decl  ->  TYPE TYPE_REAL_PTR . COLON ID SEMICOLON   (rule 61)

    COLON	shift, and go to state 190



state 143

    var_stmt  ->  VAR type_decls stmt .   (rule 44)

    $default	reduce using rule 44 (var_stmt)



state 144

    type_decls  ->  type_decls type_decl .   (rule 45)

    $default	reduce using rule 45 (type_decls)



state 145

    stmt  ->  block .   (rule 31)
    var_stmt  ->  VAR type_decls block .   (rule 43)

    $   	reduce using rule 31 (stmt)
    $   	[reduce using rule 43 (var_stmt)]
    OR  	reduce using rule 31 (stmt)
    OR  	[reduce using rule 43 (var_stmt)]
    AND 	reduce using rule 31 (stmt)
    AND 	[reduce using rule 43 (var_stmt)]
    MULT	reduce using rule 31 (stmt)
    MULT	[reduce using rule 43 (var_stmt)]
    NOT 	reduce using rule 31 (stmt)
    NOT 	[reduce using rule 43 (var_stmt)]
    ID  	reduce using rule 31 (stmt)
    ID  	[reduce using rule 43 (var_stmt)]
    CHAR_LITERAL	reduce using rule 31 (stmt)
    CHAR_LITERAL	[reduce using rule 43 (var_stmt)]
    STRING_LITERAL	reduce using rule 31 (stmt)
    STRING_LITERAL	[reduce using rule 43 (var_stmt)]
    NUM 	reduce using rule 31 (stmt)
    NUM 	[reduce using rule 43 (var_stmt)]
    TRUE	reduce using rule 31 (stmt)
    TRUE	[reduce using rule 43 (var_stmt)]
    FALSE	reduce using rule 31 (stmt)
    FALSE	[reduce using rule 43 (var_stmt)]
    DEF 	reduce using rule 31 (stmt)
    DEF 	[reduce using rule 43 (var_stmt)]
    T_BEGIN	reduce using rule 31 (stmt)
    T_BEGIN	[reduce using rule 43 (var_stmt)]
    T_END	reduce using rule 31 (stmt)
    T_END	[reduce using rule 43 (var_stmt)]
    ELIF	reduce using rule 31 (stmt)
    ELIF	[reduce using rule 43 (var_stmt)]
    WHILE	reduce using rule 31 (stmt)
    WHILE	[reduce using rule 43 (var_stmt)]
    CALL	reduce using rule 31 (stmt)
    CALL	[reduce using rule 43 (var_stmt)]
    SEMICOLON	reduce using rule 31 (stmt)
    SEMICOLON	[reduce using rule 43 (var_stmt)]
    COMMA	reduce using rule 31 (stmt)
    COMMA	[reduce using rule 43 (var_stmt)]
    LPAREN	reduce using rule 31 (stmt)
    LPAREN	[reduce using rule 43 (var_stmt)]
    RPAREN	reduce using rule 31 (stmt)
    RPAREN	[reduce using rule 43 (var_stmt)]
    LBRACK	reduce using rule 31 (stmt)
    LBRACK	[reduce using rule 43 (var_stmt)]
    RBRACK	reduce using rule 31 (stmt)
    RBRACK	[reduce using rule 43 (var_stmt)]
    BAR 	reduce using rule 31 (stmt)
    BAR 	[reduce using rule 43 (var_stmt)]
    $default	reduce using rule 31 (stmt)



state 146

    expr  ->  LPAREN expr RPAREN .   (rule 101)

    $default	reduce using rule 101 (expr)



state 147

    expr  ->  LBRACK expr RBRACK .   (rule 103)

    $default	reduce using rule 103 (expr)



state 148

    call_list  ->  call_list COMMA expr .   (rule 83)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    OR  	[reduce using rule 83 (call_list)]
    AND 	[reduce using rule 83 (call_list)]
    MULT	[reduce using rule 83 (call_list)]
    $default	reduce using rule 83 (call_list)



state 149

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)
    expr  ->  expr OR expr .   (rule 117)

    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 117 (expr)



state 150

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr AND expr .   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 116 (expr)



state 151

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr PLUS expr .   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 91 (expr)



state 152

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr MINUS expr .   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 92 (expr)



state 153

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr MULT expr .   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 93 (expr)



state 154

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr DIV expr .   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 94 (expr)



state 155

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr EQ expr .   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 95 (expr)



state 156

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr NE expr .   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 96 (expr)



state 157

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr GT expr .   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 98 (expr)



state 158

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr GE expr .   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 100 (expr)



state 159

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr LT expr .   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 97 (expr)



state 160

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr LE expr .   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)


    $default	reduce using rule 99 (expr)



state 161

    function  ->  DEF ID LPAREN par_list RPAREN COLON RETURNS type @1 . stmt_list   (rule 6)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt_list	go to state 191
    stmt	go to state 56
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 162

    assignment  ->  MULT ID ASSIGN expr . SEMICOLON   (rule 42)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 192



state 163

    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  ID LBRACK expr . RBRACK   (rule 102)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    RBRACK	shift, and go to state 193



state 164

    expr  ->  CALL ID LPAREN . call_args RPAREN   (rule 114)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $default	reduce using rule 82 (call_args)

    call_args	go to state 194
    call_list	go to state 65
    expr	go to state 69



state 165

    assignment_call  ->  ID ASSIGN CALL ID . LPAREN call_args RPAREN SEMICOLON   (rule 85)
    expr  ->  CALL ID . LPAREN call_args RPAREN   (rule 114)

    LPAREN	shift, and go to state 195



state 166

    assignment  ->  ID ASSIGN expr SEMICOLON .   (rule 40)

    $default	reduce using rule 40 (assignment)



state 167

    expr  ->  ID LPAREN call_args RPAREN .   (rule 115)

    $default	reduce using rule 115 (expr)



state 168

    assignment  ->  ID LBRACK expr RBRACK . ASSIGN expr SEMICOLON   (rule 41)
    expr  ->  ID LBRACK expr RBRACK .   (rule 102)

    ASSIGN	shift, and go to state 196

    $default	reduce using rule 102 (expr)



state 169

    block  ->  T_BEGIN @5 stmt_list T_END .   (rule 88)

    $default	reduce using rule 88 (block)



state 170

    if_stmt  ->  IF expr COLON stmt .   (rule 66)
    if_stmt  ->  IF expr COLON stmt . ELSE COLON stmt   (rule 67)

    ELSE	shift, and go to state 197

    ELSE	[reduce using rule 66 (if_stmt)]
    $default	reduce using rule 66 (if_stmt)



state 171

    stmt  ->  block .   (rule 31)
    if_stmt  ->  IF expr COLON block . ELSE COLON block   (rule 64)
    if_stmt  ->  IF expr COLON block .   (rule 65)
    if_stmt  ->  IF expr COLON block . elif_list ELSE COLON block   (rule 68)

    ELSE	shift, and go to state 198
    ELIF	shift, and go to state 199

    $   	reduce using rule 31 (stmt)
    $   	[reduce using rule 65 (if_stmt)]
    OR  	reduce using rule 31 (stmt)
    OR  	[reduce using rule 65 (if_stmt)]
    AND 	reduce using rule 31 (stmt)
    AND 	[reduce using rule 65 (if_stmt)]
    MULT	reduce using rule 31 (stmt)
    MULT	[reduce using rule 65 (if_stmt)]
    NOT 	reduce using rule 31 (stmt)
    NOT 	[reduce using rule 65 (if_stmt)]
    ID  	reduce using rule 31 (stmt)
    ID  	[reduce using rule 65 (if_stmt)]
    CHAR_LITERAL	reduce using rule 31 (stmt)
    CHAR_LITERAL	[reduce using rule 65 (if_stmt)]
    STRING_LITERAL	reduce using rule 31 (stmt)
    STRING_LITERAL	[reduce using rule 65 (if_stmt)]
    NUM 	reduce using rule 31 (stmt)
    NUM 	[reduce using rule 65 (if_stmt)]
    TRUE	reduce using rule 31 (stmt)
    TRUE	[reduce using rule 65 (if_stmt)]
    FALSE	reduce using rule 31 (stmt)
    FALSE	[reduce using rule 65 (if_stmt)]
    DEF 	reduce using rule 31 (stmt)
    DEF 	[reduce using rule 65 (if_stmt)]
    T_BEGIN	reduce using rule 31 (stmt)
    T_BEGIN	[reduce using rule 65 (if_stmt)]
    T_END	reduce using rule 31 (stmt)
    T_END	[reduce using rule 65 (if_stmt)]
    ELIF	[reduce using rule 31 (stmt)]
    ELIF	[reduce using rule 65 (if_stmt)]
    WHILE	reduce using rule 31 (stmt)
    WHILE	[reduce using rule 65 (if_stmt)]
    CALL	reduce using rule 31 (stmt)
    CALL	[reduce using rule 65 (if_stmt)]
    SEMICOLON	reduce using rule 31 (stmt)
    SEMICOLON	[reduce using rule 65 (if_stmt)]
    COMMA	reduce using rule 31 (stmt)
    COMMA	[reduce using rule 65 (if_stmt)]
    LPAREN	reduce using rule 31 (stmt)
    LPAREN	[reduce using rule 65 (if_stmt)]
    RPAREN	reduce using rule 31 (stmt)
    RPAREN	[reduce using rule 65 (if_stmt)]
    LBRACK	reduce using rule 31 (stmt)
    LBRACK	[reduce using rule 65 (if_stmt)]
    RBRACK	reduce using rule 31 (stmt)
    RBRACK	[reduce using rule 65 (if_stmt)]
    BAR 	reduce using rule 31 (stmt)
    BAR 	[reduce using rule 65 (if_stmt)]
    $default	reduce using rule 31 (stmt)

    elif_list	go to state 200



state 172

    while_stmt  ->  WHILE COLON expr SEMICOLON .   (rule 71)

    $default	reduce using rule 71 (while_stmt)



state 173

    while_stmt  ->  WHILE expr COLON stmt .   (rule 73)

    $default	reduce using rule 73 (while_stmt)



state 174

    stmt  ->  block .   (rule 31)
    while_stmt  ->  WHILE expr COLON block .   (rule 72)

    $   	reduce using rule 31 (stmt)
    $   	[reduce using rule 72 (while_stmt)]
    OR  	reduce using rule 31 (stmt)
    OR  	[reduce using rule 72 (while_stmt)]
    AND 	reduce using rule 31 (stmt)
    AND 	[reduce using rule 72 (while_stmt)]
    MULT	reduce using rule 31 (stmt)
    MULT	[reduce using rule 72 (while_stmt)]
    NOT 	reduce using rule 31 (stmt)
    NOT 	[reduce using rule 72 (while_stmt)]
    ID  	reduce using rule 31 (stmt)
    ID  	[reduce using rule 72 (while_stmt)]
    CHAR_LITERAL	reduce using rule 31 (stmt)
    CHAR_LITERAL	[reduce using rule 72 (while_stmt)]
    STRING_LITERAL	reduce using rule 31 (stmt)
    STRING_LITERAL	[reduce using rule 72 (while_stmt)]
    NUM 	reduce using rule 31 (stmt)
    NUM 	[reduce using rule 72 (while_stmt)]
    TRUE	reduce using rule 31 (stmt)
    TRUE	[reduce using rule 72 (while_stmt)]
    FALSE	reduce using rule 31 (stmt)
    FALSE	[reduce using rule 72 (while_stmt)]
    DEF 	reduce using rule 31 (stmt)
    DEF 	[reduce using rule 72 (while_stmt)]
    T_BEGIN	reduce using rule 31 (stmt)
    T_BEGIN	[reduce using rule 72 (while_stmt)]
    T_END	reduce using rule 31 (stmt)
    T_END	[reduce using rule 72 (while_stmt)]
    ELIF	reduce using rule 31 (stmt)
    ELIF	[reduce using rule 72 (while_stmt)]
    WHILE	reduce using rule 31 (stmt)
    WHILE	[reduce using rule 72 (while_stmt)]
    CALL	reduce using rule 31 (stmt)
    CALL	[reduce using rule 72 (while_stmt)]
    SEMICOLON	reduce using rule 31 (stmt)
    SEMICOLON	[reduce using rule 72 (while_stmt)]
    COMMA	reduce using rule 31 (stmt)
    COMMA	[reduce using rule 72 (while_stmt)]
    LPAREN	reduce using rule 31 (stmt)
    LPAREN	[reduce using rule 72 (while_stmt)]
    RPAREN	reduce using rule 31 (stmt)
    RPAREN	[reduce using rule 72 (while_stmt)]
    LBRACK	reduce using rule 31 (stmt)
    LBRACK	[reduce using rule 72 (while_stmt)]
    RBRACK	reduce using rule 31 (stmt)
    RBRACK	[reduce using rule 72 (while_stmt)]
    BAR 	reduce using rule 31 (stmt)
    BAR 	[reduce using rule 72 (while_stmt)]
    $default	reduce using rule 31 (stmt)



state 175

    assignment  ->  MULT ID . ASSIGN expr SEMICOLON   (rule 42)

    ASSIGN	shift, and go to state 114



state 176

    assignment  ->  ID ASSIGN . expr SEMICOLON   (rule 40)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 119



state 177

    assignment  ->  ID LBRACK . expr RBRACK ASSIGN expr SEMICOLON   (rule 41)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 201



state 178

    for_stmt  ->  FOR LPAREN assignment expr . SEMICOLON update_expr RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment expr . SEMICOLON update_expr RPAREN COLON stmt   (rule 78)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 202



state 179

    while_stmt  ->  WHILE . COLON expr SEMICOLON   (rule 71)
    while_stmt  ->  WHILE . expr COLON block   (rule 72)
    while_stmt  ->  WHILE . expr COLON stmt   (rule 73)
    do_while_stmt  ->  DO COLON stmt_list WHILE . expr SEMICOLON   (rule 74)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    COLON	shift, and go to state 84
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 203



state 180

    do_while_stmt  ->  DO COLON stmt WHILE . expr SEMICOLON   (rule 75)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 204



state 181

    do_while_stmt  ->  DO COLON block WHILE . expr SEMICOLON   (rule 76)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 205



state 182

    void_call  ->  CALL ID LPAREN call_args . RPAREN SEMICOLON   (rule 86)
    expr  ->  CALL ID LPAREN call_args . RPAREN   (rule 114)

    RPAREN	shift, and go to state 206



state 183

    type_decl  ->  TYPE TYPE_INT COLON . ID SEMICOLON   (rule 47)
    type_decl  ->  TYPE TYPE_INT COLON . ID COLON NUM SEMICOLON   (rule 53)

    ID  	shift, and go to state 207



state 184

    type_decl  ->  TYPE TYPE_CHAR COLON . ID SEMICOLON   (rule 49)
    type_decl  ->  TYPE TYPE_CHAR COLON . ID COLON CHAR_LITERAL SEMICOLON   (rule 54)

    ID  	shift, and go to state 208



state 185

    type_decl  ->  TYPE TYPE_REAL COLON . ID SEMICOLON   (rule 51)
    type_decl  ->  TYPE TYPE_REAL COLON . ID COLON NUM SEMICOLON   (rule 52)

    ID  	shift, and go to state 209



state 186

    type_decl  ->  TYPE TYPE_BOOL COLON . ID SEMICOLON   (rule 48)
    type_decl  ->  TYPE TYPE_BOOL COLON . ID COLON TRUE SEMICOLON   (rule 56)
    type_decl  ->  TYPE TYPE_BOOL COLON . ID COLON FALSE SEMICOLON   (rule 57)

    ID  	shift, and go to state 210



state 187

    type_decl  ->  TYPE TYPE_STRING COLON . ID SEMICOLON   (rule 50)
    type_decl  ->  TYPE TYPE_STRING COLON . ID COLON STRING_LITERAL SEMICOLON   (rule 55)
    type_decl  ->  TYPE TYPE_STRING COLON . ID LBRACK NUM RBRACK SEMICOLON   (rule 58)

    ID  	shift, and go to state 211



state 188

    type_decl  ->  TYPE TYPE_INT_PTR COLON . ID SEMICOLON   (rule 59)

    ID  	shift, and go to state 212



state 189

    type_decl  ->  TYPE TYPE_CHAR_PTR COLON . ID SEMICOLON   (rule 60)

    ID  	shift, and go to state 213



state 190

    type_decl  ->  TYPE TYPE_REAL_PTR COLON . ID SEMICOLON   (rule 61)

    ID  	shift, and go to state 214



state 191

    function  ->  DEF ID LPAREN par_list RPAREN COLON RETURNS type @1 stmt_list .   (rule 6)
    stmt_list  ->  stmt_list . stmt   (rule 26)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $   	reduce using rule 6 (function)
    $   	[reduce using rule 82 (call_args)]
    OR  	[reduce using rule 6 (function)]
    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 6 (function)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 6 (function)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 6 (function)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 6 (function)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 6 (function)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 6 (function)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 6 (function)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 6 (function)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 6 (function)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 6 (function)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 6 (function)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    T_END	reduce using rule 6 (function)
    T_END	[reduce using rule 82 (call_args)]
    ELIF	reduce using rule 6 (function)
    ELIF	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 6 (function)]
    WHILE	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 6 (function)]
    CALL	[reduce using rule 82 (call_args)]
    SEMICOLON	reduce using rule 6 (function)
    SEMICOLON	[reduce using rule 82 (call_args)]
    COMMA	reduce using rule 6 (function)
    COMMA	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 6 (function)]
    LPAREN	[reduce using rule 82 (call_args)]
    RPAREN	reduce using rule 6 (function)
    RPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 6 (function)]
    LBRACK	[reduce using rule 82 (call_args)]
    RBRACK	reduce using rule 6 (function)
    RBRACK	[reduce using rule 82 (call_args)]
    BAR 	reduce using rule 6 (function)
    BAR 	[reduce using rule 82 (call_args)]
    $default	reduce using rule 6 (function)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 97
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 192

    assignment  ->  MULT ID ASSIGN expr SEMICOLON .   (rule 42)

    $default	reduce using rule 42 (assignment)



state 193

    expr  ->  ID LBRACK expr RBRACK .   (rule 102)

    $default	reduce using rule 102 (expr)



state 194

    expr  ->  CALL ID LPAREN call_args . RPAREN   (rule 114)

    RPAREN	shift, and go to state 215



state 195

    assignment_call  ->  ID ASSIGN CALL ID LPAREN . call_args RPAREN SEMICOLON   (rule 85)
    expr  ->  CALL ID LPAREN . call_args RPAREN   (rule 114)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    $default	reduce using rule 82 (call_args)

    call_args	go to state 216
    call_list	go to state 65
    expr	go to state 69



state 196

    assignment  ->  ID LBRACK expr RBRACK ASSIGN . expr SEMICOLON   (rule 41)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 217



state 197

    if_stmt  ->  IF expr COLON stmt ELSE . COLON stmt   (rule 67)

    COLON	shift, and go to state 218



state 198

    if_stmt  ->  IF expr COLON block ELSE . COLON block   (rule 64)

    COLON	shift, and go to state 219



state 199

    elif_list  ->  ELIF . expr COLON block   (rule 69)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 220



state 200

    if_stmt  ->  IF expr COLON block elif_list . ELSE COLON block   (rule 68)
    elif_list  ->  elif_list . ELIF expr COLON block   (rule 70)

    ELSE	shift, and go to state 221
    ELIF	shift, and go to state 222



state 201

    assignment  ->  ID LBRACK expr . RBRACK ASSIGN expr SEMICOLON   (rule 41)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    RBRACK	shift, and go to state 223



state 202

    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON . update_expr RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON . update_expr RPAREN COLON stmt   (rule 78)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 224
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    update_expr	go to state 225
    expr	go to state 226



state 203

    while_stmt  ->  WHILE expr . COLON block   (rule 72)
    while_stmt  ->  WHILE expr . COLON stmt   (rule 73)
    do_while_stmt  ->  DO COLON stmt_list WHILE expr . SEMICOLON   (rule 74)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    COLON	shift, and go to state 126
    SEMICOLON	shift, and go to state 227



state 204

    do_while_stmt  ->  DO COLON stmt WHILE expr . SEMICOLON   (rule 75)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 228



state 205

    do_while_stmt  ->  DO COLON block WHILE expr . SEMICOLON   (rule 76)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 229



state 206

    void_call  ->  CALL ID LPAREN call_args RPAREN . SEMICOLON   (rule 86)
    expr  ->  CALL ID LPAREN call_args RPAREN .   (rule 114)

    SEMICOLON	shift, and go to state 230

    $default	reduce using rule 114 (expr)



state 207

    type_decl  ->  TYPE TYPE_INT COLON ID . SEMICOLON   (rule 47)
    type_decl  ->  TYPE TYPE_INT COLON ID . COLON NUM SEMICOLON   (rule 53)

    COLON	shift, and go to state 231
    SEMICOLON	shift, and go to state 232



state 208

    type_decl  ->  TYPE TYPE_CHAR COLON ID . SEMICOLON   (rule 49)
    type_decl  ->  TYPE TYPE_CHAR COLON ID . COLON CHAR_LITERAL SEMICOLON   (rule 54)

    COLON	shift, and go to state 233
    SEMICOLON	shift, and go to state 234



state 209

    type_decl  ->  TYPE TYPE_REAL COLON ID . SEMICOLON   (rule 51)
    type_decl  ->  TYPE TYPE_REAL COLON ID . COLON NUM SEMICOLON   (rule 52)

    COLON	shift, and go to state 235
    SEMICOLON	shift, and go to state 236



state 210

    type_decl  ->  TYPE TYPE_BOOL COLON ID . SEMICOLON   (rule 48)
    type_decl  ->  TYPE TYPE_BOOL COLON ID . COLON TRUE SEMICOLON   (rule 56)
    type_decl  ->  TYPE TYPE_BOOL COLON ID . COLON FALSE SEMICOLON   (rule 57)

    COLON	shift, and go to state 237
    SEMICOLON	shift, and go to state 238



state 211

    type_decl  ->  TYPE TYPE_STRING COLON ID . SEMICOLON   (rule 50)
    type_decl  ->  TYPE TYPE_STRING COLON ID . COLON STRING_LITERAL SEMICOLON   (rule 55)
    type_decl  ->  TYPE TYPE_STRING COLON ID . LBRACK NUM RBRACK SEMICOLON   (rule 58)

    COLON	shift, and go to state 239
    SEMICOLON	shift, and go to state 240
    LBRACK	shift, and go to state 241



state 212

    type_decl  ->  TYPE TYPE_INT_PTR COLON ID . SEMICOLON   (rule 59)

    SEMICOLON	shift, and go to state 242



state 213

    type_decl  ->  TYPE TYPE_CHAR_PTR COLON ID . SEMICOLON   (rule 60)

    SEMICOLON	shift, and go to state 243



state 214

    type_decl  ->  TYPE TYPE_REAL_PTR COLON ID . SEMICOLON   (rule 61)

    SEMICOLON	shift, and go to state 244



state 215

    expr  ->  CALL ID LPAREN call_args RPAREN .   (rule 114)

    $default	reduce using rule 114 (expr)



state 216

    assignment_call  ->  ID ASSIGN CALL ID LPAREN call_args . RPAREN SEMICOLON   (rule 85)
    expr  ->  CALL ID LPAREN call_args . RPAREN   (rule 114)

    RPAREN	shift, and go to state 245



state 217

    assignment  ->  ID LBRACK expr RBRACK ASSIGN expr . SEMICOLON   (rule 41)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    SEMICOLON	shift, and go to state 246



state 218

    if_stmt  ->  IF expr COLON stmt ELSE COLON . stmt   (rule 67)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 247
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 68
    expr	go to state 69



state 219

    if_stmt  ->  IF expr COLON block ELSE COLON . block   (rule 64)

    T_BEGIN	shift, and go to state 42

    block	go to state 248



state 220

    elif_list  ->  ELIF expr . COLON block   (rule 69)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    COLON	shift, and go to state 249



state 221

    if_stmt  ->  IF expr COLON block elif_list ELSE . COLON block   (rule 68)

    COLON	shift, and go to state 250



state 222

    elif_list  ->  elif_list ELIF . expr COLON block   (rule 70)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 251



state 223

    assignment  ->  ID LBRACK expr RBRACK . ASSIGN expr SEMICOLON   (rule 41)

    ASSIGN	shift, and go to state 196



state 224

    update_expr  ->  ID . ASSIGN expr   (rule 79)
    expr  ->  ID . LBRACK expr RBRACK   (rule 102)
    expr  ->  ID .   (rule 105)
    expr  ->  ID . LPAREN call_args RPAREN   (rule 115)

    ASSIGN	shift, and go to state 252
    LPAREN	shift, and go to state 79
    LBRACK	shift, and go to state 116

    $default	reduce using rule 105 (expr)



state 225

    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr . RPAREN COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr . RPAREN COLON stmt   (rule 78)

    RPAREN	shift, and go to state 253



state 226

    update_expr  ->  expr .   (rule 80)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 80 (update_expr)



state 227

    do_while_stmt  ->  DO COLON stmt_list WHILE expr SEMICOLON .   (rule 74)

    $default	reduce using rule 74 (do_while_stmt)



state 228

    do_while_stmt  ->  DO COLON stmt WHILE expr SEMICOLON .   (rule 75)

    $default	reduce using rule 75 (do_while_stmt)



state 229

    do_while_stmt  ->  DO COLON block WHILE expr SEMICOLON .   (rule 76)

    $default	reduce using rule 76 (do_while_stmt)



state 230

    void_call  ->  CALL ID LPAREN call_args RPAREN SEMICOLON .   (rule 86)

    $default	reduce using rule 86 (void_call)



state 231

    type_decl  ->  TYPE TYPE_INT COLON ID COLON . NUM SEMICOLON   (rule 53)

    NUM 	shift, and go to state 254



state 232

    type_decl  ->  TYPE TYPE_INT COLON ID SEMICOLON .   (rule 47)

    $default	reduce using rule 47 (type_decl)



state 233

    type_decl  ->  TYPE TYPE_CHAR COLON ID COLON . CHAR_LITERAL SEMICOLON   (rule 54)

    CHAR_LITERAL	shift, and go to state 255



state 234

    type_decl  ->  TYPE TYPE_CHAR COLON ID SEMICOLON .   (rule 49)

    $default	reduce using rule 49 (type_decl)



state 235

    type_decl  ->  TYPE TYPE_REAL COLON ID COLON . NUM SEMICOLON   (rule 52)

    NUM 	shift, and go to state 256



state 236

    type_decl  ->  TYPE TYPE_REAL COLON ID SEMICOLON .   (rule 51)

    $default	reduce using rule 51 (type_decl)



state 237

    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON . TRUE SEMICOLON   (rule 56)
    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON . FALSE SEMICOLON   (rule 57)

    TRUE	shift, and go to state 257
    FALSE	shift, and go to state 258



state 238

    type_decl  ->  TYPE TYPE_BOOL COLON ID SEMICOLON .   (rule 48)

    $default	reduce using rule 48 (type_decl)



state 239

    type_decl  ->  TYPE TYPE_STRING COLON ID COLON . STRING_LITERAL SEMICOLON   (rule 55)

    STRING_LITERAL	shift, and go to state 259



state 240

    type_decl  ->  TYPE TYPE_STRING COLON ID SEMICOLON .   (rule 50)

    $default	reduce using rule 50 (type_decl)



state 241

    type_decl  ->  TYPE TYPE_STRING COLON ID LBRACK . NUM RBRACK SEMICOLON   (rule 58)

    NUM 	shift, and go to state 260



state 242

    type_decl  ->  TYPE TYPE_INT_PTR COLON ID SEMICOLON .   (rule 59)

    $default	reduce using rule 59 (type_decl)



state 243

    type_decl  ->  TYPE TYPE_CHAR_PTR COLON ID SEMICOLON .   (rule 60)

    $default	reduce using rule 60 (type_decl)



state 244

    type_decl  ->  TYPE TYPE_REAL_PTR COLON ID SEMICOLON .   (rule 61)

    $default	reduce using rule 61 (type_decl)



state 245

    assignment_call  ->  ID ASSIGN CALL ID LPAREN call_args RPAREN . SEMICOLON   (rule 85)
    expr  ->  CALL ID LPAREN call_args RPAREN .   (rule 114)

    SEMICOLON	shift, and go to state 261

    SEMICOLON	[reduce using rule 114 (expr)]
    $default	reduce using rule 114 (expr)



state 246

    assignment  ->  ID LBRACK expr RBRACK ASSIGN expr SEMICOLON .   (rule 41)

    $default	reduce using rule 41 (assignment)



state 247

    if_stmt  ->  IF expr COLON stmt ELSE COLON stmt .   (rule 67)

    $default	reduce using rule 67 (if_stmt)



state 248

    if_stmt  ->  IF expr COLON block ELSE COLON block .   (rule 64)

    $default	reduce using rule 64 (if_stmt)



state 249

    elif_list  ->  ELIF expr COLON . block   (rule 69)

    T_BEGIN	shift, and go to state 42

    block	go to state 262



state 250

    if_stmt  ->  IF expr COLON block elif_list ELSE COLON . block   (rule 68)

    T_BEGIN	shift, and go to state 42

    block	go to state 263



state 251

    elif_list  ->  elif_list ELIF expr . COLON block   (rule 70)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110
    COLON	shift, and go to state 264



state 252

    update_expr  ->  ID ASSIGN . expr   (rule 79)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 74
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 75
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    CALL	shift, and go to state 76
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    expr	go to state 265



state 253

    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN . COLON block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN . COLON stmt   (rule 78)

    COLON	shift, and go to state 266



state 254

    type_decl  ->  TYPE TYPE_INT COLON ID COLON NUM . SEMICOLON   (rule 53)

    SEMICOLON	shift, and go to state 267



state 255

    type_decl  ->  TYPE TYPE_CHAR COLON ID COLON CHAR_LITERAL . SEMICOLON   (rule 54)

    SEMICOLON	shift, and go to state 268



state 256

    type_decl  ->  TYPE TYPE_REAL COLON ID COLON NUM . SEMICOLON   (rule 52)

    SEMICOLON	shift, and go to state 269



state 257

    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON TRUE . SEMICOLON   (rule 56)

    SEMICOLON	shift, and go to state 270



state 258

    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON FALSE . SEMICOLON   (rule 57)

    SEMICOLON	shift, and go to state 271



state 259

    type_decl  ->  TYPE TYPE_STRING COLON ID COLON STRING_LITERAL . SEMICOLON   (rule 55)

    SEMICOLON	shift, and go to state 272



state 260

    type_decl  ->  TYPE TYPE_STRING COLON ID LBRACK NUM . RBRACK SEMICOLON   (rule 58)

    RBRACK	shift, and go to state 273



state 261

    assignment_call  ->  ID ASSIGN CALL ID LPAREN call_args RPAREN SEMICOLON .   (rule 85)

    $default	reduce using rule 85 (assignment_call)



state 262

    elif_list  ->  ELIF expr COLON block .   (rule 69)

    $default	reduce using rule 69 (elif_list)



state 263

    if_stmt  ->  IF expr COLON block elif_list ELSE COLON block .   (rule 68)

    $default	reduce using rule 68 (if_stmt)



state 264

    elif_list  ->  elif_list ELIF expr COLON . block   (rule 70)

    T_BEGIN	shift, and go to state 42

    block	go to state 274



state 265

    update_expr  ->  ID ASSIGN expr .   (rule 79)
    expr  ->  expr . PLUS expr   (rule 91)
    expr  ->  expr . MINUS expr   (rule 92)
    expr  ->  expr . MULT expr   (rule 93)
    expr  ->  expr . DIV expr   (rule 94)
    expr  ->  expr . EQ expr   (rule 95)
    expr  ->  expr . NE expr   (rule 96)
    expr  ->  expr . LT expr   (rule 97)
    expr  ->  expr . GT expr   (rule 98)
    expr  ->  expr . LE expr   (rule 99)
    expr  ->  expr . GE expr   (rule 100)
    expr  ->  expr . AND expr   (rule 116)
    expr  ->  expr . OR expr   (rule 117)

    OR  	shift, and go to state 99
    AND 	shift, and go to state 100
    PLUS	shift, and go to state 101
    MINUS	shift, and go to state 102
    MULT	shift, and go to state 103
    DIV 	shift, and go to state 104
    EQ  	shift, and go to state 105
    NE  	shift, and go to state 106
    GT  	shift, and go to state 107
    GE  	shift, and go to state 108
    LT  	shift, and go to state 109
    LE  	shift, and go to state 110

    $default	reduce using rule 79 (update_expr)



state 266

    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON . block   (rule 77)
    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON . stmt   (rule 78)

    OR  	shift, and go to state 32
    AND 	shift, and go to state 33
    MULT	shift, and go to state 34
    NOT 	shift, and go to state 35
    ID  	shift, and go to state 36
    CHAR_LITERAL	shift, and go to state 37
    STRING_LITERAL	shift, and go to state 38
    NUM 	shift, and go to state 39
    TRUE	shift, and go to state 40
    FALSE	shift, and go to state 41
    DEF 	shift, and go to state 2
    T_BEGIN	shift, and go to state 42
    IF  	shift, and go to state 43
    WHILE	shift, and go to state 44
    FOR 	shift, and go to state 45
    DO  	shift, and go to state 46
    CALL	shift, and go to state 47
    RETURN	shift, and go to state 48
    VAR 	shift, and go to state 49
    NULLPTR	shift, and go to state 50
    ADDRESS	shift, and go to state 51
    LPAREN	shift, and go to state 52
    LBRACK	shift, and go to state 53

    OR  	[reduce using rule 82 (call_args)]
    AND 	[reduce using rule 82 (call_args)]
    MULT	[reduce using rule 82 (call_args)]
    NOT 	[reduce using rule 82 (call_args)]
    ID  	[reduce using rule 82 (call_args)]
    CHAR_LITERAL	[reduce using rule 82 (call_args)]
    STRING_LITERAL	[reduce using rule 82 (call_args)]
    NUM 	[reduce using rule 82 (call_args)]
    TRUE	[reduce using rule 82 (call_args)]
    FALSE	[reduce using rule 82 (call_args)]
    DEF 	[reduce using rule 82 (call_args)]
    T_BEGIN	[reduce using rule 82 (call_args)]
    IF  	[reduce using rule 82 (call_args)]
    WHILE	[reduce using rule 82 (call_args)]
    FOR 	[reduce using rule 82 (call_args)]
    DO  	[reduce using rule 82 (call_args)]
    CALL	[reduce using rule 82 (call_args)]
    RETURN	[reduce using rule 82 (call_args)]
    VAR 	[reduce using rule 82 (call_args)]
    NULLPTR	[reduce using rule 82 (call_args)]
    ADDRESS	[reduce using rule 82 (call_args)]
    LPAREN	[reduce using rule 82 (call_args)]
    LBRACK	[reduce using rule 82 (call_args)]
    $default	reduce using rule 82 (call_args)

    func_list	go to state 54
    function	go to state 4
    stmt	go to state 275
    assignment	go to state 57
    var_stmt	go to state 58
    return_stmt	go to state 59
    if_stmt	go to state 60
    while_stmt	go to state 61
    do_while_stmt	go to state 62
    for_stmt	go to state 63
    call_args	go to state 64
    call_list	go to state 65
    assignment_call	go to state 66
    void_call	go to state 67
    block	go to state 276
    expr	go to state 69



state 267

    type_decl  ->  TYPE TYPE_INT COLON ID COLON NUM SEMICOLON .   (rule 53)

    $default	reduce using rule 53 (type_decl)



state 268

    type_decl  ->  TYPE TYPE_CHAR COLON ID COLON CHAR_LITERAL SEMICOLON .   (rule 54)

    $default	reduce using rule 54 (type_decl)



state 269

    type_decl  ->  TYPE TYPE_REAL COLON ID COLON NUM SEMICOLON .   (rule 52)

    $default	reduce using rule 52 (type_decl)



state 270

    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON TRUE SEMICOLON .   (rule 56)

    $default	reduce using rule 56 (type_decl)



state 271

    type_decl  ->  TYPE TYPE_BOOL COLON ID COLON FALSE SEMICOLON .   (rule 57)

    $default	reduce using rule 57 (type_decl)



state 272

    type_decl  ->  TYPE TYPE_STRING COLON ID COLON STRING_LITERAL SEMICOLON .   (rule 55)

    $default	reduce using rule 55 (type_decl)



state 273

    type_decl  ->  TYPE TYPE_STRING COLON ID LBRACK NUM RBRACK . SEMICOLON   (rule 58)

    SEMICOLON	shift, and go to state 277



state 274

    elif_list  ->  elif_list ELIF expr COLON block .   (rule 70)

    $default	reduce using rule 70 (elif_list)



state 275

    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON stmt .   (rule 78)

    $default	reduce using rule 78 (for_stmt)



state 276

    stmt  ->  block .   (rule 31)
    for_stmt  ->  FOR LPAREN assignment expr SEMICOLON update_expr RPAREN COLON block .   (rule 77)

    $   	reduce using rule 31 (stmt)
    $   	[reduce using rule 77 (for_stmt)]
    OR  	reduce using rule 31 (stmt)
    OR  	[reduce using rule 77 (for_stmt)]
    AND 	reduce using rule 31 (stmt)
    AND 	[reduce using rule 77 (for_stmt)]
    MULT	reduce using rule 31 (stmt)
    MULT	[reduce using rule 77 (for_stmt)]
    NOT 	reduce using rule 31 (stmt)
    NOT 	[reduce using rule 77 (for_stmt)]
    ID  	reduce using rule 31 (stmt)
    ID  	[reduce using rule 77 (for_stmt)]
    CHAR_LITERAL	reduce using rule 31 (stmt)
    CHAR_LITERAL	[reduce using rule 77 (for_stmt)]
    STRING_LITERAL	reduce using rule 31 (stmt)
    STRING_LITERAL	[reduce using rule 77 (for_stmt)]
    NUM 	reduce using rule 31 (stmt)
    NUM 	[reduce using rule 77 (for_stmt)]
    TRUE	reduce using rule 31 (stmt)
    TRUE	[reduce using rule 77 (for_stmt)]
    FALSE	reduce using rule 31 (stmt)
    FALSE	[reduce using rule 77 (for_stmt)]
    DEF 	reduce using rule 31 (stmt)
    DEF 	[reduce using rule 77 (for_stmt)]
    T_BEGIN	reduce using rule 31 (stmt)
    T_BEGIN	[reduce using rule 77 (for_stmt)]
    T_END	reduce using rule 31 (stmt)
    T_END	[reduce using rule 77 (for_stmt)]
    ELIF	reduce using rule 31 (stmt)
    ELIF	[reduce using rule 77 (for_stmt)]
    WHILE	reduce using rule 31 (stmt)
    WHILE	[reduce using rule 77 (for_stmt)]
    CALL	reduce using rule 31 (stmt)
    CALL	[reduce using rule 77 (for_stmt)]
    SEMICOLON	reduce using rule 31 (stmt)
    SEMICOLON	[reduce using rule 77 (for_stmt)]
    COMMA	reduce using rule 31 (stmt)
    COMMA	[reduce using rule 77 (for_stmt)]
    LPAREN	reduce using rule 31 (stmt)
    LPAREN	[reduce using rule 77 (for_stmt)]
    RPAREN	reduce using rule 31 (stmt)
    RPAREN	[reduce using rule 77 (for_stmt)]
    LBRACK	reduce using rule 31 (stmt)
    LBRACK	[reduce using rule 77 (for_stmt)]
    RBRACK	reduce using rule 31 (stmt)
    RBRACK	[reduce using rule 77 (for_stmt)]
    BAR 	reduce using rule 31 (stmt)
    BAR 	[reduce using rule 77 (for_stmt)]
    $default	reduce using rule 31 (stmt)



state 277

    type_decl  ->  TYPE TYPE_STRING COLON ID LBRACK NUM RBRACK SEMICOLON .   (rule 58)

    $default	reduce using rule 58 (type_decl)



state 278

    $   	go to state 279



state 279

    $   	go to state 280



state 280

    $default	accept
